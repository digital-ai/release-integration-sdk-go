/*
Digital.ai Release API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// DeliveryPatternApiService DeliveryPatternApi service
type DeliveryPatternApiService service

type ApiCheckTitleRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	validatePattern *ValidatePattern
}

func (r ApiCheckTitleRequest) ValidatePattern(validatePattern ValidatePattern) ApiCheckTitleRequest {
	r.validatePattern = &validatePattern
	return r
}

func (r ApiCheckTitleRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.CheckTitleExecute(r)
}

/*
CheckTitle Method for CheckTitle

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckTitleRequest
*/
func (a *DeliveryPatternApiService) CheckTitle(ctx context.Context) ApiCheckTitleRequest {
	return ApiCheckTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *DeliveryPatternApiService) CheckTitleExecute(r ApiCheckTitleRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CheckTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/checkTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validatePattern
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDeliveryFromPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	createDelivery *CreateDelivery
}

func (r ApiCreateDeliveryFromPatternRequest) CreateDelivery(createDelivery CreateDelivery) ApiCreateDeliveryFromPatternRequest {
	r.createDelivery = &createDelivery
	return r
}

func (r ApiCreateDeliveryFromPatternRequest) Execute() (*Delivery, *http.Response, error) {
	return r.ApiService.CreateDeliveryFromPatternExecute(r)
}

/*
CreateDeliveryFromPattern Method for CreateDeliveryFromPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiCreateDeliveryFromPatternRequest
*/
func (a *DeliveryPatternApiService) CreateDeliveryFromPattern(ctx context.Context, patternId string) ApiCreateDeliveryFromPatternRequest {
	return ApiCreateDeliveryFromPatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return Delivery
func (a *DeliveryPatternApiService) CreateDeliveryFromPatternExecute(r ApiCreateDeliveryFromPatternRequest) (*Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreateDeliveryFromPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/create"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDelivery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	delivery *Delivery
}

func (r ApiCreatePatternRequest) Delivery(delivery Delivery) ApiCreatePatternRequest {
	r.delivery = &delivery
	return r
}

func (r ApiCreatePatternRequest) Execute() (*Delivery, *http.Response, error) {
	return r.ApiService.CreatePatternExecute(r)
}

/*
CreatePattern Method for CreatePattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePatternRequest
*/
func (a *DeliveryPatternApiService) CreatePattern(ctx context.Context) ApiCreatePatternRequest {
	return ApiCreatePatternRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Delivery
func (a *DeliveryPatternApiService) CreatePatternExecute(r ApiCreatePatternRequest) (*Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreatePattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.delivery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStageRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	createDeliveryStage *CreateDeliveryStage
}

func (r ApiCreateStageRequest) CreateDeliveryStage(createDeliveryStage CreateDeliveryStage) ApiCreateStageRequest {
	r.createDeliveryStage = &createDeliveryStage
	return r
}

func (r ApiCreateStageRequest) Execute() (*Stage, *http.Response, error) {
	return r.ApiService.CreateStageExecute(r)
}

/*
CreateStage Method for CreateStage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiCreateStageRequest
*/
func (a *DeliveryPatternApiService) CreateStage(ctx context.Context, patternId string) ApiCreateStageRequest {
	return ApiCreateStageRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return Stage
func (a *DeliveryPatternApiService) CreateStageExecute(r ApiCreateStageRequest) (*Stage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreateStage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/createStage"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDeliveryStage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStage1Request struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	stage *Stage
}

func (r ApiCreateStage1Request) Stage(stage Stage) ApiCreateStage1Request {
	r.stage = &stage
	return r
}

func (r ApiCreateStage1Request) Execute() (*Stage, *http.Response, error) {
	return r.ApiService.CreateStage1Execute(r)
}

/*
CreateStage1 Method for CreateStage1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiCreateStage1Request
*/
func (a *DeliveryPatternApiService) CreateStage1(ctx context.Context, patternId string) ApiCreateStage1Request {
	return ApiCreateStage1Request{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return Stage
func (a *DeliveryPatternApiService) CreateStage1Execute(r ApiCreateStage1Request) (*Stage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreateStage1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/stages"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStage2Request struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	position int32
	stage *Stage
}

func (r ApiCreateStage2Request) Stage(stage Stage) ApiCreateStage2Request {
	r.stage = &stage
	return r
}

func (r ApiCreateStage2Request) Execute() (*Stage, *http.Response, error) {
	return r.ApiService.CreateStage2Execute(r)
}

/*
CreateStage2 Method for CreateStage2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @param position
 @return ApiCreateStage2Request
*/
func (a *DeliveryPatternApiService) CreateStage2(ctx context.Context, patternId string, position int32) ApiCreateStage2Request {
	return ApiCreateStage2Request{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
		position: position,
	}
}

// Execute executes the request
//  @return Stage
func (a *DeliveryPatternApiService) CreateStage2Execute(r ApiCreateStage2Request) (*Stage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreateStage2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/stages/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTrackedItemInPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	trackedItem *TrackedItem
}

func (r ApiCreateTrackedItemInPatternRequest) TrackedItem(trackedItem TrackedItem) ApiCreateTrackedItemInPatternRequest {
	r.trackedItem = &trackedItem
	return r
}

func (r ApiCreateTrackedItemInPatternRequest) Execute() (*TrackedItem, *http.Response, error) {
	return r.ApiService.CreateTrackedItemInPatternExecute(r)
}

/*
CreateTrackedItemInPattern Method for CreateTrackedItemInPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiCreateTrackedItemInPatternRequest
*/
func (a *DeliveryPatternApiService) CreateTrackedItemInPattern(ctx context.Context, patternId string) ApiCreateTrackedItemInPatternRequest {
	return ApiCreateTrackedItemInPatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return TrackedItem
func (a *DeliveryPatternApiService) CreateTrackedItemInPatternExecute(r ApiCreateTrackedItemInPatternRequest) (*TrackedItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackedItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreateTrackedItemInPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/tracked-items"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.trackedItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTransitionRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	stageId string
	transition *Transition
}

func (r ApiCreateTransitionRequest) Transition(transition Transition) ApiCreateTransitionRequest {
	r.transition = &transition
	return r
}

func (r ApiCreateTransitionRequest) Execute() (*Transition, *http.Response, error) {
	return r.ApiService.CreateTransitionExecute(r)
}

/*
CreateTransition Method for CreateTransition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stageId
 @return ApiCreateTransitionRequest
*/
func (a *DeliveryPatternApiService) CreateTransition(ctx context.Context, stageId string) ApiCreateTransitionRequest {
	return ApiCreateTransitionRequest{
		ApiService: a,
		ctx: ctx,
		stageId: stageId,
	}
}

// Execute executes the request
//  @return Transition
func (a *DeliveryPatternApiService) CreateTransitionExecute(r ApiCreateTransitionRequest) (*Transition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.CreateTransition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{stageId}/transitions"
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
}

func (r ApiDeletePatternRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePatternExecute(r)
}

/*
DeletePattern Method for DeletePattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiDeletePatternRequest
*/
func (a *DeliveryPatternApiService) DeletePattern(ctx context.Context, patternId string) ApiDeletePatternRequest {
	return ApiDeletePatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
func (a *DeliveryPatternApiService) DeletePatternExecute(r ApiDeletePatternRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.DeletePattern")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteStageRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	stageId string
}

func (r ApiDeleteStageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteStageExecute(r)
}

/*
DeleteStage Method for DeleteStage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stageId
 @return ApiDeleteStageRequest
*/
func (a *DeliveryPatternApiService) DeleteStage(ctx context.Context, stageId string) ApiDeleteStageRequest {
	return ApiDeleteStageRequest{
		ApiService: a,
		ctx: ctx,
		stageId: stageId,
	}
}

// Execute executes the request
func (a *DeliveryPatternApiService) DeleteStageExecute(r ApiDeleteStageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.DeleteStage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{stageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTrackedItemDeliveryPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	itemId string
}

func (r ApiDeleteTrackedItemDeliveryPatternRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTrackedItemDeliveryPatternExecute(r)
}

/*
DeleteTrackedItemDeliveryPattern Method for DeleteTrackedItemDeliveryPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId
 @return ApiDeleteTrackedItemDeliveryPatternRequest
*/
func (a *DeliveryPatternApiService) DeleteTrackedItemDeliveryPattern(ctx context.Context, itemId string) ApiDeleteTrackedItemDeliveryPatternRequest {
	return ApiDeleteTrackedItemDeliveryPatternRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
func (a *DeliveryPatternApiService) DeleteTrackedItemDeliveryPatternExecute(r ApiDeleteTrackedItemDeliveryPatternRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.DeleteTrackedItemDeliveryPattern")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTransitionRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	transitionId string
}

func (r ApiDeleteTransitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTransitionExecute(r)
}

/*
DeleteTransition Method for DeleteTransition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transitionId
 @return ApiDeleteTransitionRequest
*/
func (a *DeliveryPatternApiService) DeleteTransition(ctx context.Context, transitionId string) ApiDeleteTransitionRequest {
	return ApiDeleteTransitionRequest{
		ApiService: a,
		ctx: ctx,
		transitionId: transitionId,
	}
}

// Execute executes the request
func (a *DeliveryPatternApiService) DeleteTransitionExecute(r ApiDeleteTransitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.DeleteTransition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{transitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transitionId"+"}", url.PathEscape(parameterValueToString(r.transitionId, "transitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDuplicatePatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	duplicateDeliveryPattern *DuplicateDeliveryPattern
}

func (r ApiDuplicatePatternRequest) DuplicateDeliveryPattern(duplicateDeliveryPattern DuplicateDeliveryPattern) ApiDuplicatePatternRequest {
	r.duplicateDeliveryPattern = &duplicateDeliveryPattern
	return r
}

func (r ApiDuplicatePatternRequest) Execute() (*Delivery, *http.Response, error) {
	return r.ApiService.DuplicatePatternExecute(r)
}

/*
DuplicatePattern Method for DuplicatePattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiDuplicatePatternRequest
*/
func (a *DeliveryPatternApiService) DuplicatePattern(ctx context.Context, patternId string) ApiDuplicatePatternRequest {
	return ApiDuplicatePatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return Delivery
func (a *DeliveryPatternApiService) DuplicatePatternExecute(r ApiDuplicatePatternRequest) (*Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.DuplicatePattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.duplicateDeliveryPattern
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
}

func (r ApiGetPatternRequest) Execute() (*Delivery, *http.Response, error) {
	return r.ApiService.GetPatternExecute(r)
}

/*
GetPattern Method for GetPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiGetPatternRequest
*/
func (a *DeliveryPatternApiService) GetPattern(ctx context.Context, patternId string) ApiGetPatternRequest {
	return ApiGetPatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return Delivery
func (a *DeliveryPatternApiService) GetPatternExecute(r ApiGetPatternRequest) (*Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.GetPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPatternByIdOrTitleRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternIdOrTitle string
}

func (r ApiGetPatternByIdOrTitleRequest) Execute() (*Delivery, *http.Response, error) {
	return r.ApiService.GetPatternByIdOrTitleExecute(r)
}

/*
GetPatternByIdOrTitle Method for GetPatternByIdOrTitle

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternIdOrTitle
 @return ApiGetPatternByIdOrTitleRequest
*/
func (a *DeliveryPatternApiService) GetPatternByIdOrTitle(ctx context.Context, patternIdOrTitle string) ApiGetPatternByIdOrTitleRequest {
	return ApiGetPatternByIdOrTitleRequest{
		ApiService: a,
		ctx: ctx,
		patternIdOrTitle: patternIdOrTitle,
	}
}

// Execute executes the request
//  @return Delivery
func (a *DeliveryPatternApiService) GetPatternByIdOrTitleExecute(r ApiGetPatternByIdOrTitleRequest) (*Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.GetPatternByIdOrTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternIdOrTitle}"
	localVarPath = strings.Replace(localVarPath, "{"+"patternIdOrTitle"+"}", url.PathEscape(parameterValueToString(r.patternIdOrTitle, "patternIdOrTitle")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStagesInPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
}

func (r ApiGetStagesInPatternRequest) Execute() ([]Stage, *http.Response, error) {
	return r.ApiService.GetStagesInPatternExecute(r)
}

/*
GetStagesInPattern Method for GetStagesInPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiGetStagesInPatternRequest
*/
func (a *DeliveryPatternApiService) GetStagesInPattern(ctx context.Context, patternId string) ApiGetStagesInPatternRequest {
	return ApiGetStagesInPatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return []Stage
func (a *DeliveryPatternApiService) GetStagesInPatternExecute(r ApiGetStagesInPatternRequest) ([]Stage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.GetStagesInPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/stages"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrackedItemsInPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
}

func (r ApiGetTrackedItemsInPatternRequest) Execute() ([]TrackedItem, *http.Response, error) {
	return r.ApiService.GetTrackedItemsInPatternExecute(r)
}

/*
GetTrackedItemsInPattern Method for GetTrackedItemsInPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiGetTrackedItemsInPatternRequest
*/
func (a *DeliveryPatternApiService) GetTrackedItemsInPattern(ctx context.Context, patternId string) ApiGetTrackedItemsInPatternRequest {
	return ApiGetTrackedItemsInPatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return []TrackedItem
func (a *DeliveryPatternApiService) GetTrackedItemsInPatternExecute(r ApiGetTrackedItemsInPatternRequest) ([]TrackedItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TrackedItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.GetTrackedItemsInPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}/tracked-items"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPatternsRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	page *int64
	resultsPerPage *int64
	deliveryPatternFilters *DeliveryPatternFilters
}

func (r ApiSearchPatternsRequest) Page(page int64) ApiSearchPatternsRequest {
	r.page = &page
	return r
}

func (r ApiSearchPatternsRequest) ResultsPerPage(resultsPerPage int64) ApiSearchPatternsRequest {
	r.resultsPerPage = &resultsPerPage
	return r
}

func (r ApiSearchPatternsRequest) DeliveryPatternFilters(deliveryPatternFilters DeliveryPatternFilters) ApiSearchPatternsRequest {
	r.deliveryPatternFilters = &deliveryPatternFilters
	return r
}

func (r ApiSearchPatternsRequest) Execute() ([]Delivery, *http.Response, error) {
	return r.ApiService.SearchPatternsExecute(r)
}

/*
SearchPatterns Method for SearchPatterns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPatternsRequest
*/
func (a *DeliveryPatternApiService) SearchPatterns(ctx context.Context) ApiSearchPatternsRequest {
	return ApiSearchPatternsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Delivery
func (a *DeliveryPatternApiService) SearchPatternsExecute(r ApiSearchPatternsRequest) ([]Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.SearchPatterns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.resultsPerPage != nil {
		parameterAddToQuery(localVarQueryParams, "resultsPerPage", r.resultsPerPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deliveryPatternFilters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	patternId string
	delivery *Delivery
}

func (r ApiUpdatePatternRequest) Delivery(delivery Delivery) ApiUpdatePatternRequest {
	r.delivery = &delivery
	return r
}

func (r ApiUpdatePatternRequest) Execute() (*Delivery, *http.Response, error) {
	return r.ApiService.UpdatePatternExecute(r)
}

/*
UpdatePattern Method for UpdatePattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param patternId
 @return ApiUpdatePatternRequest
*/
func (a *DeliveryPatternApiService) UpdatePattern(ctx context.Context, patternId string) ApiUpdatePatternRequest {
	return ApiUpdatePatternRequest{
		ApiService: a,
		ctx: ctx,
		patternId: patternId,
	}
}

// Execute executes the request
//  @return Delivery
func (a *DeliveryPatternApiService) UpdatePatternExecute(r ApiUpdatePatternRequest) (*Delivery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Delivery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.UpdatePattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{patternId}"
	localVarPath = strings.Replace(localVarPath, "{"+"patternId"+"}", url.PathEscape(parameterValueToString(r.patternId, "patternId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.delivery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStageFromBatchRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	stageId string
	stage *Stage
}

func (r ApiUpdateStageFromBatchRequest) Stage(stage Stage) ApiUpdateStageFromBatchRequest {
	r.stage = &stage
	return r
}

func (r ApiUpdateStageFromBatchRequest) Execute() (*Stage, *http.Response, error) {
	return r.ApiService.UpdateStageFromBatchExecute(r)
}

/*
UpdateStageFromBatch Method for UpdateStageFromBatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stageId
 @return ApiUpdateStageFromBatchRequest
*/
func (a *DeliveryPatternApiService) UpdateStageFromBatch(ctx context.Context, stageId string) ApiUpdateStageFromBatchRequest {
	return ApiUpdateStageFromBatchRequest{
		ApiService: a,
		ctx: ctx,
		stageId: stageId,
	}
}

// Execute executes the request
//  @return Stage
func (a *DeliveryPatternApiService) UpdateStageFromBatchExecute(r ApiUpdateStageFromBatchRequest) (*Stage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.UpdateStageFromBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{stageId}/batched"
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStageInPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	stageId string
	stage *Stage
}

func (r ApiUpdateStageInPatternRequest) Stage(stage Stage) ApiUpdateStageInPatternRequest {
	r.stage = &stage
	return r
}

func (r ApiUpdateStageInPatternRequest) Execute() (*Stage, *http.Response, error) {
	return r.ApiService.UpdateStageInPatternExecute(r)
}

/*
UpdateStageInPattern Method for UpdateStageInPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stageId
 @return ApiUpdateStageInPatternRequest
*/
func (a *DeliveryPatternApiService) UpdateStageInPattern(ctx context.Context, stageId string) ApiUpdateStageInPatternRequest {
	return ApiUpdateStageInPatternRequest{
		ApiService: a,
		ctx: ctx,
		stageId: stageId,
	}
}

// Execute executes the request
//  @return Stage
func (a *DeliveryPatternApiService) UpdateStageInPatternExecute(r ApiUpdateStageInPatternRequest) (*Stage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.UpdateStageInPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{stageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTrackedItemInPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	itemId string
	trackedItem *TrackedItem
}

func (r ApiUpdateTrackedItemInPatternRequest) TrackedItem(trackedItem TrackedItem) ApiUpdateTrackedItemInPatternRequest {
	r.trackedItem = &trackedItem
	return r
}

func (r ApiUpdateTrackedItemInPatternRequest) Execute() (*TrackedItem, *http.Response, error) {
	return r.ApiService.UpdateTrackedItemInPatternExecute(r)
}

/*
UpdateTrackedItemInPattern Method for UpdateTrackedItemInPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId
 @return ApiUpdateTrackedItemInPatternRequest
*/
func (a *DeliveryPatternApiService) UpdateTrackedItemInPattern(ctx context.Context, itemId string) ApiUpdateTrackedItemInPatternRequest {
	return ApiUpdateTrackedItemInPatternRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return TrackedItem
func (a *DeliveryPatternApiService) UpdateTrackedItemInPatternExecute(r ApiUpdateTrackedItemInPatternRequest) (*TrackedItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackedItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.UpdateTrackedItemInPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.trackedItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTransitionInPatternRequest struct {
	ctx context.Context
	ApiService *DeliveryPatternApiService
	transitionId string
	transition *Transition
}

func (r ApiUpdateTransitionInPatternRequest) Transition(transition Transition) ApiUpdateTransitionInPatternRequest {
	r.transition = &transition
	return r
}

func (r ApiUpdateTransitionInPatternRequest) Execute() (*Transition, *http.Response, error) {
	return r.ApiService.UpdateTransitionInPatternExecute(r)
}

/*
UpdateTransitionInPattern Method for UpdateTransitionInPattern

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transitionId
 @return ApiUpdateTransitionInPatternRequest
*/
func (a *DeliveryPatternApiService) UpdateTransitionInPattern(ctx context.Context, transitionId string) ApiUpdateTransitionInPatternRequest {
	return ApiUpdateTransitionInPatternRequest{
		ApiService: a,
		ctx: ctx,
		transitionId: transitionId,
	}
}

// Execute executes the request
//  @return Transition
func (a *DeliveryPatternApiService) UpdateTransitionInPatternExecute(r ApiUpdateTransitionInPatternRequest) (*Transition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeliveryPatternApiService.UpdateTransitionInPattern")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/delivery-patterns/{transitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transitionId"+"}", url.PathEscape(parameterValueToString(r.transitionId, "transitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
